<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libtheora: theoraenc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libtheora<span id="projectnumber">&#160;1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_0f91760d62c578de767c41a0aaae5482.html">theora</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">theoraenc.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <span class="tt">libtheoraenc</span> C encoding API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;ogg/ogg.h&gt;</code><br />
<code>#include &quot;<a class="el" href="codec_8h_source.html">codec.h</a>&quot;</code><br />
</div>
<p><a href="theoraenc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab43b2364621da8df29ee636107fef234" id="r_ab43b2364621da8df29ee636107fef234"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab43b2364621da8df29ee636107fef234">OGG_THEORA_THEORAENC_HEADER</a>&#160;&#160;&#160;(1)</td></tr>
<tr id="define-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">th_encode_ctl() codes</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="encctlcodes"></a>These are the available request codes for <a class="el" href="#a3a427f6514dfdc01ea72172c469d51d9" title="Encoder control function.">th_encode_ctl()</a>.</p>
<p>By convention, these are even, to distinguish them from the <a class="el" href="theoradec_8h.html#decctlcodes">decoder control codes</a>. Keep any experimental or vendor-specific values above <code>0x8000</code>. </p>
</div></td></tr>
<tr class="memitem:a0165348788e560a19b7c61ae8f0c2283" id="r_a0165348788e560a19b7c61ae8f0c2283"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0165348788e560a19b7c61ae8f0c2283">TH_ENCCTL_SET_HUFFMAN_CODES</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a0165348788e560a19b7c61ae8f0c2283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Huffman tables to use.  <br /></td></tr>
<tr class="memitem:a3befcdd66678f8d27034f9c4b16d1b9c" id="r_a3befcdd66678f8d27034f9c4b16d1b9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3befcdd66678f8d27034f9c4b16d1b9c">TH_ENCCTL_SET_QUANT_PARAMS</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:a3befcdd66678f8d27034f9c4b16d1b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the quantization parameters to use.  <br /></td></tr>
<tr class="memitem:a27e755e15b4b5604c54974b304037a49" id="r_a27e755e15b4b5604c54974b304037a49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e755e15b4b5604c54974b304037a49">TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a27e755e15b4b5604c54974b304037a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum distance between key frames.  <br /></td></tr>
<tr class="memitem:a382d685a39a34d8e6ba76b00d804efd8" id="r_a382d685a39a34d8e6ba76b00d804efd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a382d685a39a34d8e6ba76b00d804efd8">TH_ENCCTL_SET_VP3_COMPATIBLE</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a382d685a39a34d8e6ba76b00d804efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables any encoder features that would prevent lossless transcoding back to VP3.  <br /></td></tr>
<tr class="memitem:a9baf5bdd206e80c78a8fd44687e89783" id="r_a9baf5bdd206e80c78a8fd44687e89783"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9baf5bdd206e80c78a8fd44687e89783">TH_ENCCTL_GET_SPLEVEL_MAX</a>&#160;&#160;&#160;(12)</td></tr>
<tr class="memdesc:a9baf5bdd206e80c78a8fd44687e89783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum speed level.  <br /></td></tr>
<tr class="memitem:abd9fbcb6a25a77d991d3620164fe59d6" id="r_abd9fbcb6a25a77d991d3620164fe59d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd9fbcb6a25a77d991d3620164fe59d6">TH_ENCCTL_SET_SPLEVEL</a>&#160;&#160;&#160;(14)</td></tr>
<tr class="memdesc:abd9fbcb6a25a77d991d3620164fe59d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the speed level.  <br /></td></tr>
<tr class="memitem:a114b7c552f50b7b8d881a39489af1f61" id="r_a114b7c552f50b7b8d881a39489af1f61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a114b7c552f50b7b8d881a39489af1f61">TH_ENCCTL_GET_SPLEVEL</a>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:a114b7c552f50b7b8d881a39489af1f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current speed level.  <br /></td></tr>
<tr class="memitem:a8bb9b05471c42a09f8684a2583b8a1df" id="r_a8bb9b05471c42a09f8684a2583b8a1df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb9b05471c42a09f8684a2583b8a1df">TH_ENCCTL_SET_DUP_COUNT</a>&#160;&#160;&#160;(18)</td></tr>
<tr class="memdesc:a8bb9b05471c42a09f8684a2583b8a1df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of duplicates of the next frame to produce.  <br /></td></tr>
<tr class="memitem:a026502e08fbe1af0a1063f39bd18129c" id="r_a026502e08fbe1af0a1063f39bd18129c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a026502e08fbe1af0a1063f39bd18129c">TH_ENCCTL_SET_RATE_FLAGS</a>&#160;&#160;&#160;(20)</td></tr>
<tr class="memdesc:a026502e08fbe1af0a1063f39bd18129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the default bitrate management behavior.  <br /></td></tr>
<tr class="memitem:aaefb515876b2a180ad5c3120fc584a52" id="r_aaefb515876b2a180ad5c3120fc584a52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaefb515876b2a180ad5c3120fc584a52">TH_ENCCTL_SET_RATE_BUFFER</a>&#160;&#160;&#160;(22)</td></tr>
<tr class="memdesc:aaefb515876b2a180ad5c3120fc584a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the bitrate management bit reservoir as a function of number of frames.  <br /></td></tr>
<tr class="memitem:ac3751b9c3838888ec2e3f0b0d2823282" id="r_ac3751b9c3838888ec2e3f0b0d2823282"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3751b9c3838888ec2e3f0b0d2823282">TH_ENCCTL_2PASS_OUT</a>&#160;&#160;&#160;(24)</td></tr>
<tr class="memdesc:ac3751b9c3838888ec2e3f0b0d2823282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable pass 1 of two-pass encoding mode and retrieve the first pass metrics.  <br /></td></tr>
<tr class="memitem:a4a84f982cdd9a3e3c803a29bbde9df0b" id="r_a4a84f982cdd9a3e3c803a29bbde9df0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a84f982cdd9a3e3c803a29bbde9df0b">TH_ENCCTL_2PASS_IN</a>&#160;&#160;&#160;(26)</td></tr>
<tr class="memdesc:a4a84f982cdd9a3e3c803a29bbde9df0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits two-pass encoding metric data collected the first encoding pass to the second pass.  <br /></td></tr>
<tr class="memitem:aac087983fa951b9148c9db6bc2e81ef4" id="r_aac087983fa951b9148c9db6bc2e81ef4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac087983fa951b9148c9db6bc2e81ef4">TH_ENCCTL_SET_QUALITY</a>&#160;&#160;&#160;(28)</td></tr>
<tr class="memdesc:aac087983fa951b9148c9db6bc2e81ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current encoding quality.  <br /></td></tr>
<tr class="memitem:a9b969df55ecad1acd1ae207fad42592e" id="r_a9b969df55ecad1acd1ae207fad42592e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b969df55ecad1acd1ae207fad42592e">TH_ENCCTL_SET_BITRATE</a>&#160;&#160;&#160;(30)</td></tr>
<tr class="memdesc:a9b969df55ecad1acd1ae207fad42592e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current encoding bitrate.  <br /></td></tr>
<tr class="memitem:aeb3085ec96e06eca81b3a372e5ed9bff" id="r_aeb3085ec96e06eca81b3a372e5ed9bff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3085ec96e06eca81b3a372e5ed9bff">TH_ENCCTL_SET_COMPAT_CONFIG</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="memdesc:aeb3085ec96e06eca81b3a372e5ed9bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the configuration to be compatible with that from the given setup header.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr id="typedef-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Encoder state</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The following data structure is opaque, and its contents are not publicly defined by this API.</p>
<p>Referring to its internals directly is unsupported, and may break without warning. </p>
</div></td></tr>
<tr class="memitem:af5cc40472b925456d42526a035d66edd" id="r_af5cc40472b925456d42526a035d66edd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a></td></tr>
<tr class="memdesc:af5cc40472b925456d42526a035d66edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The encoder context.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Functions for encoding</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>You must link to <span class="tt">libtheoraenc</span> and <span class="tt">libtheoradec</span> if you use any of the functions in this section.</p>
<p>The functions are listed in the order they are used in a typical encode. The basic steps are:</p><ul>
<li>Fill in a <a class="el" href="structth__info.html" title="Theora bitstream information.">th_info</a> structure with details on the format of the video you wish to encode.</li>
<li>Allocate a <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle with <a class="el" href="#aad036b5967e07629b9be10a4d77ada00" title="Allocates an encoder instance.">th_encode_alloc()</a>.</li>
<li>Perform any additional encoder configuration required with <a class="el" href="#a3a427f6514dfdc01ea72172c469d51d9" title="Encoder control function.">th_encode_ctl()</a>.</li>
<li>Repeatedly call <a class="el" href="#a9439d61b566039d194ff782681fbc408" title="Outputs the next header packet.">th_encode_flushheader()</a> to retrieve all the header packets.</li>
<li>For each uncompressed frame:<ul>
<li>Submit the uncompressed frame via <a class="el" href="#adbe7dd66b411c2d61ab8153c15308750" title="Submits an uncompressed frame to the encoder.">th_encode_ycbcr_in()</a></li>
<li>Repeatedly call <a class="el" href="#a96d8ac1dda53187455352f99bbb5b04b" title="Retrieves encoded video data packets.">th_encode_packetout()</a> to retrieve any video data packets that are ready.</li>
</ul>
</li>
<li>Call <a class="el" href="#a36b23d216532231925c4107894204680" title="Frees an allocated encoder instance.">th_encode_free()</a> to release all encoder memory. </li>
</ul>
</div></td></tr>
<tr class="memitem:aad036b5967e07629b9be10a4d77ada00" id="r_aad036b5967e07629b9be10a4d77ada00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad036b5967e07629b9be10a4d77ada00">th_encode_alloc</a> (const <a class="el" href="structth__info.html">th_info</a> *_info)</td></tr>
<tr class="memdesc:aad036b5967e07629b9be10a4d77ada00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an encoder instance.  <br /></td></tr>
<tr class="memitem:a3a427f6514dfdc01ea72172c469d51d9" id="r_a3a427f6514dfdc01ea72172c469d51d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a427f6514dfdc01ea72172c469d51d9">th_encode_ctl</a> (<a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *_enc, int _req, void *_buf, size_t _buf_sz)</td></tr>
<tr class="memdesc:a3a427f6514dfdc01ea72172c469d51d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoder control function.  <br /></td></tr>
<tr class="memitem:a9439d61b566039d194ff782681fbc408" id="r_a9439d61b566039d194ff782681fbc408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9439d61b566039d194ff782681fbc408">th_encode_flushheader</a> (<a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *_enc, <a class="el" href="structth__comment.html">th_comment</a> *_comments, ogg_packet *_op)</td></tr>
<tr class="memdesc:a9439d61b566039d194ff782681fbc408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the next header packet.  <br /></td></tr>
<tr class="memitem:adbe7dd66b411c2d61ab8153c15308750" id="r_adbe7dd66b411c2d61ab8153c15308750"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbe7dd66b411c2d61ab8153c15308750">th_encode_ycbcr_in</a> (<a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *_enc, <a class="el" href="codec_8h.html#a343f7cfabad179cc4fe527cf06873f45">th_ycbcr_buffer</a> _ycbcr)</td></tr>
<tr class="memdesc:adbe7dd66b411c2d61ab8153c15308750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits an uncompressed frame to the encoder.  <br /></td></tr>
<tr class="memitem:a96d8ac1dda53187455352f99bbb5b04b" id="r_a96d8ac1dda53187455352f99bbb5b04b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96d8ac1dda53187455352f99bbb5b04b">th_encode_packetout</a> (<a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *_enc, int _last, ogg_packet *_op)</td></tr>
<tr class="memdesc:a96d8ac1dda53187455352f99bbb5b04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves encoded video data packets.  <br /></td></tr>
<tr class="memitem:a36b23d216532231925c4107894204680" id="r_a36b23d216532231925c4107894204680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b23d216532231925c4107894204680">th_encode_free</a> (<a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *_enc)</td></tr>
<tr class="memdesc:a36b23d216532231925c4107894204680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an allocated encoder instance.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
TH_ENCCTL_SET_RATE_FLAGS flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="ratectlflags"></a>These are the flags available for use with <a class="el" href="#a026502e08fbe1af0a1063f39bd18129c" title="Modifies the default bitrate management behavior.">TH_ENCCTL_SET_RATE_FLAGS</a>. </p>
</td></tr>
<tr class="memitem:a3e7fab53b902b54135522ba286f45e33" id="r_a3e7fab53b902b54135522ba286f45e33"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e7fab53b902b54135522ba286f45e33">TH_RATECTL_DROP_FRAMES</a>&#160;&#160;&#160;(0x1)</td></tr>
<tr class="memdesc:a3e7fab53b902b54135522ba286f45e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop frames to keep within bitrate buffer constraints.  <br /></td></tr>
<tr class="memitem:a32f9983b344a431334493cefb0b9337c" id="r_a32f9983b344a431334493cefb0b9337c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f9983b344a431334493cefb0b9337c">TH_RATECTL_CAP_OVERFLOW</a>&#160;&#160;&#160;(0x2)</td></tr>
<tr class="memdesc:a32f9983b344a431334493cefb0b9337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore bitrate buffer overflows.  <br /></td></tr>
<tr class="memitem:ad0d62d9dce542caf5296b03b97e020a6" id="r_ad0d62d9dce542caf5296b03b97e020a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d62d9dce542caf5296b03b97e020a6">TH_RATECTL_CAP_UNDERFLOW</a>&#160;&#160;&#160;(0x4)</td></tr>
<tr class="memdesc:ad0d62d9dce542caf5296b03b97e020a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore bitrate buffer underflows.  <br /></td></tr>
<tr class="memitem:a3b1b462989f4e7a5a98e6e697f1a7f7d" id="r_a3b1b462989f4e7a5a98e6e697f1a7f7d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structth__quant__info.html">th_quant_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1b462989f4e7a5a98e6e697f1a7f7d">TH_VP31_QUANT_INFO</a></td></tr>
<tr class="memdesc:a3b1b462989f4e7a5a98e6e697f1a7f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quantization parameters used by VP3.  <br /></td></tr>
<tr class="memitem:aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e" id="r_aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structth__huff__code.html">th_huff_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e">TH_VP31_HUFF_CODES</a> [<a class="el" href="codec_8h.html#a49bf449eae33c5320f0c308f32c6ae42">TH_NHUFFMAN_TABLES</a>][<a class="el" href="codec_8h.html#a2a44f48084e76a58cae48fb5d47cd422">TH_NDCT_TOKENS</a>]</td></tr>
<tr class="memdesc:aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Huffman tables used by VP3.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <span class="tt">libtheoraenc</span> C encoding API. </p>
</div><a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ab43b2364621da8df29ee636107fef234" name="ab43b2364621da8df29ee636107fef234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43b2364621da8df29ee636107fef234">&#9670;&#160;</a></span>OGG_THEORA_THEORAENC_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OGG_THEORA_THEORAENC_HEADER&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a84f982cdd9a3e3c803a29bbde9df0b" name="a4a84f982cdd9a3e3c803a29bbde9df0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a84f982cdd9a3e3c803a29bbde9df0b">&#9670;&#160;</a></span>TH_ENCCTL_2PASS_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_2PASS_IN&#160;&#160;&#160;(26)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits two-pass encoding metric data collected the first encoding pass to the second pass. </p>
<p>The first call must be made before the first frame is encoded, and a target bitrate must have already been specified to the encoder. It sets the encoder to pass 2 mode implicitly; this cannot be disabled. The encoder may require reading data from some or all of the frames in advance, depending on, e.g., the reservoir size used in the second pass. You must call this function repeatedly before each frame to provide data until either a) it fails to consume all of the data presented or b) all of the pass 1 data has been consumed. In the first case, you must save the remaining data to be presented after the next frame. You can call this function with a NULL argument to get an upper bound on the number of bytes that will be required before the next frame.</p>
<p>When pass 2 is first enabled, the default bit reservoir is set to the entire file; this gives maximum flexibility but can lead to very high peak rates. You can subsequently set it to another value with <a class="el" href="#aaefb515876b2a180ad5c3120fc584a52" title="Sets the size of the bitrate management bit reservoir as a function of number of frames.">TH_ENCCTL_SET_RATE_BUFFER</a> (e.g., to set it to the keyframe interval for non-live streaming), however, you may then need to provide more data before the next frame.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">char[]</span>: A buffer containing the data returned by <a class="el" href="#ac3751b9c3838888ec2e3f0b0d2823282" title="Enable pass 1 of two-pass encoding mode and retrieve the first pass metrics.">TH_ENCCTL_2PASS_OUT</a> in pass 1. You may pass <span class="tt">NULL</span> for <em class="arg">_buf</em> to return an upper bound on the number of additional bytes needed before the next frame. The summary data returned at the end of pass 1 must be at the head of the buffer on the first call with a non-<span class="tt">NULL</span> <em class="arg">_buf</em>, and the placeholder data returned at the start of pass 1 should be omitted. After each call you should advance this buffer by the number of bytes consumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>The number of bytes of metric data required/consumed. </td></tr>
    <tr><td class="paramname">0</td><td>No more data is required before the next frame. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>No target bitrate has been set, or the first call was made after the first frame was submitted for encoding. </td></tr>
    <tr><td class="paramname">TH_ENOTFORMAT</td><td>The data did not appear to be pass 1 from a compatible implementation of this library. </td></tr>
    <tr><td class="paramname">TH_EBADHEADER</td><td>The data was invalid; this may be returned when attempting to read an aborted pass 1 file that still has the placeholder data in place of the summary data. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3751b9c3838888ec2e3f0b0d2823282" name="ac3751b9c3838888ec2e3f0b0d2823282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3751b9c3838888ec2e3f0b0d2823282">&#9670;&#160;</a></span>TH_ENCCTL_2PASS_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_2PASS_OUT&#160;&#160;&#160;(24)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable pass 1 of two-pass encoding mode and retrieve the first pass metrics. </p>
<p>Pass 1 mode must be enabled before the first frame is encoded, and a target bitrate must have already been specified to the encoder. Although this does not have to be the exact rate that will be used in the second pass, closer values may produce better results. The first call returns the size of the two-pass header data, along with some placeholder content, and sets the encoder into pass 1 mode implicitly. This call sets the encoder to pass 1 mode implicitly. Then, a subsequent call must be made after each call to <a class="el" href="#adbe7dd66b411c2d61ab8153c15308750" title="Submits an uncompressed frame to the encoder.">th_encode_ycbcr_in()</a> to retrieve the metrics for that frame. An additional, final call must be made to retrieve the summary data, containing such information as the total number of frames, etc. This must be stored in place of the placeholder data that was returned in the first call, before the frame metrics data. All of this data must be presented back to the encoder during pass 2 using <a class="el" href="#a4a84f982cdd9a3e3c803a29bbde9df0b" title="Submits two-pass encoding metric data collected the first encoding pass to the second pass.">TH_ENCCTL_2PASS_IN</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">&lt;tt&gt;char</td><td>*_buf: Returns a pointer to internal storage containing the two pass metrics data. This storage is only valid until the next call, or until the encoder context is freed, and must be copied by the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;=0</td><td>The number of bytes of metric data available in the returned buffer. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(char *)</span>, no target bitrate has been set, or the first call was made after the first frame was submitted for encoding. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114b7c552f50b7b8d881a39489af1f61" name="a114b7c552f50b7b8d881a39489af1f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114b7c552f50b7b8d881a39489af1f61">&#9670;&#160;</a></span>TH_ENCCTL_GET_SPLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_GET_SPLEVEL&#160;&#160;&#160;(16)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current speed level. </p>
<p>The default speed level may vary according to encoder implementation, but if this control code is not supported (it returns <a class="el" href="codec_8h.html#a921c47accc17841f220af5a6afb79efe" title="The specified function is not implemented.">TH_EIMPL</a>), the default may be assumed to be the slowest available speed (0). The maximum encoding speed level may be implementation- and encoding mode-specific, and can be obtained via <a class="el" href="#a9baf5bdd206e80c78a8fd44687e89783" title="Gets the maximum speed level.">TH_ENCCTL_GET_SPLEVEL_MAX</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The current encoding speed level. 0 is slowest, larger values use less CPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9baf5bdd206e80c78a8fd44687e89783" name="a9baf5bdd206e80c78a8fd44687e89783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf5bdd206e80c78a8fd44687e89783">&#9670;&#160;</a></span>TH_ENCCTL_GET_SPLEVEL_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_GET_SPLEVEL_MAX&#160;&#160;&#160;(12)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum speed level. </p>
<p>Higher speed levels favor quicker encoding over better quality per bit. Depending on the encoding mode, and the internal algorithms used, quality may actually improve, but in this case bitrate will also likely increase. In any case, overall rate/distortion performance will probably decrease. The maximum value, and the meaning of each value, may change depending on the current encoding mode (VBR vs. constant quality, etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The maximum encoding speed level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b969df55ecad1acd1ae207fad42592e" name="a9b969df55ecad1acd1ae207fad42592e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b969df55ecad1acd1ae207fad42592e">&#9670;&#160;</a></span>TH_ENCCTL_SET_BITRATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_BITRATE&#160;&#160;&#160;(30)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current encoding bitrate. </p>
<p>Once a bitrate is set, the encoder must use a rate-controlled mode for all future frames (this restriction may be relaxed in a future version). If it is set before the headers are emitted, the target bitrate encoded in them will be updated. Due to the buffer delay, the exact bitrate of each section of the encode is not guaranteed. The encoder may have already used more bits than allowed for the frames it has encoded, expecting to make them up in future frames, or it may have used fewer, holding the excess in reserve. The exact transition between the two bitrates is not well-defined by this API, but may be affected by flags set with <a class="el" href="#a026502e08fbe1af0a1063f39bd18129c" title="Modifies the default bitrate management behavior.">TH_ENCCTL_SET_RATE_FLAGS</a>. After a number of frames equal to the buffer delay, one may expect further output to average at the target bitrate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">long</span>: The new target bitrate, in bits per second. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>The target bitrate was not positive. A future version of this library may allow passing 0 to disabled rate-controlled mode and return to a quality-based mode, in which case this function will not return an error for that value. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb3085ec96e06eca81b3a372e5ed9bff" name="aeb3085ec96e06eca81b3a372e5ed9bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3085ec96e06eca81b3a372e5ed9bff">&#9670;&#160;</a></span>TH_ENCCTL_SET_COMPAT_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_COMPAT_CONFIG&#160;&#160;&#160;(32)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the configuration to be compatible with that from the given setup header. </p>
<p>This sets the Huffman codebooks and quantization parameters to match those found in the given setup header. This guarantees that packets encoded by this encoder will be decodable using a decoder configured with the passed-in setup header. It does <em>not</em> guarantee that <a class="el" href="#a9439d61b566039d194ff782681fbc408" title="Outputs the next header packet.">th_encode_flushheader()</a> will produce a bit-identical setup header, only that they will be compatible. If you need a bit-identical setup header, then use the one you passed into this command, and not the one returned by <a class="el" href="#a9439d61b566039d194ff782681fbc408" title="Outputs the next header packet.">th_encode_flushheader()</a>.</p>
<p>This also does <em>not</em> enable or disable VP3 compatibility; that is not signaled in the setup header (or anywhere else in the encoded stream), and is controlled independently by the <a class="el" href="#a382d685a39a34d8e6ba76b00d804efd8" title="Disables any encoder features that would prevent lossless transcoding back to VP3.">TH_ENCCTL_SET_VP3_COMPATIBLE</a> function. If you wish to enable VP3 compatibility mode <em>and</em> want the codebooks and quantization parameters to match the given setup header, you should enable VP3 compatibility before invoking this command, otherwise the codebooks and quantization parameters will be reset to the VP3 defaults.</p>
<p>The current encoder does not support Huffman codebooks which do not contain codewords for all 32 tokens. Such codebooks are legal, according to the specification, but cannot be configured with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">unsigned char[]</span>: The encoded setup header to copy the configuration from. This should be the original, undecoded setup header packet, and <em>not</em> a <a class="el" href="theoradec_8h.html#ab71cd2657455cc27d6c0127c66a89f28" title="Setup information.">th_setup_info</a> structure filled in by <a class="el" href="theoradec_8h.html#a006d01d36fbe64768c571e6a12b7fc50" title="Decodes the header packets of a Theora stream.">th_decode_headerin()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>Encoding has already begun, so the codebooks and quantization parameters cannot be changed, or the data in the setup header was not supported by this encoder. </td></tr>
    <tr><td class="paramname">TH_EBADHEADER</td><td><em class="arg">_buf</em> did not contain a valid setup header packet. </td></tr>
    <tr><td class="paramname">TH_ENOTFORMAT</td><td><em class="arg">_buf</em> did not contain a Theora header at all. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb9b05471c42a09f8684a2583b8a1df" name="a8bb9b05471c42a09f8684a2583b8a1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb9b05471c42a09f8684a2583b8a1df">&#9670;&#160;</a></span>TH_ENCCTL_SET_DUP_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_DUP_COUNT&#160;&#160;&#160;(18)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of duplicates of the next frame to produce. </p>
<p>Although libtheora can encode duplicate frames very cheaply, it costs some amount of CPU to detect them, and a run of duplicates cannot span a keyframe boundary. This control code tells the encoder to produce the specified number of extra duplicates of the next frame. This allows the encoder to make smarter keyframe placement decisions and rate control decisions, and reduces CPU usage as well, when compared to just submitting the same frame for encoding multiple times. This setting only applies to the next frame submitted for encoding. You MUST call <a class="el" href="#a96d8ac1dda53187455352f99bbb5b04b" title="Retrieves encoded video data packets.">th_encode_packetout()</a> repeatedly until it returns 0, or the extra duplicate frames will be lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The number of duplicates to produce. If this is negative or zero, no duplicates will be produced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>, or the number of duplicates is greater than or equal to the maximum keyframe interval. In the latter case, NO duplicate frames will be produced. You must ensure that the maximum keyframe interval is set larger than the maximum number of duplicates you will ever wish to insert prior to encoding. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0165348788e560a19b7c61ae8f0c2283" name="a0165348788e560a19b7c61ae8f0c2283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0165348788e560a19b7c61ae8f0c2283">&#9670;&#160;</a></span>TH_ENCCTL_SET_HUFFMAN_CODES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_HUFFMAN_CODES&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Huffman tables to use. </p>
<p>The tables are copied, not stored by reference, so they can be freed after this call. <span class="tt">NULL</span> may be specified to revert to the default tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt"><a class="el" href="structth__huff__code.html" title="A Huffman code for a Theora DCT token.">th_huff_code</a>[<a class="el" href="codec_8h.html#a49bf449eae33c5320f0c308f32c6ae42" title="The number of Huffman tables used by Theora.">TH_NHUFFMAN_TABLES</a>][<a class="el" href="codec_8h.html#a2a44f48084e76a58cae48fb5d47cd422" title="The number of DCT token values in each table.">TH_NDCT_TOKENS</a>]</span> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>Encoding has already begun or one or more of the given tables is not full or prefix-free, <em class="arg">_buf</em> is <span class="tt">NULL</span> and <em class="arg">_buf_sz</em> is not zero, or <em class="arg">_buf</em> is non-<span class="tt">NULL</span> and <em class="arg">_buf_sz</em> is not <span class="tt">sizeof(<a class="el" href="structth__huff__code.html" title="A Huffman code for a Theora DCT token.">th_huff_code</a>)*<a class="el" href="codec_8h.html#a49bf449eae33c5320f0c308f32c6ae42" title="The number of Huffman tables used by Theora.">TH_NHUFFMAN_TABLES</a>*<a class="el" href="codec_8h.html#a2a44f48084e76a58cae48fb5d47cd422" title="The number of DCT token values in each table.">TH_NDCT_TOKENS</a></span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e755e15b4b5604c54974b304037a49" name="a27e755e15b4b5604c54974b304037a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e755e15b4b5604c54974b304037a49">&#9670;&#160;</a></span>TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum distance between key frames. </p>
<p>This can be changed during an encode, but will be bounded by <span class="tt">1&lt;&lt;<a class="el" href="structth__info.html#a693ca4ab11fbc0c3f32594b4bb8766ed" title="The amount to shift to extract the last keyframe number from the granule position.">th_info::keyframe_granule_shift</a></span>. If it is set before encoding begins, <a class="el" href="structth__info.html#a693ca4ab11fbc0c3f32594b4bb8766ed" title="The amount to shift to extract the last keyframe number from the granule position.">th_info::keyframe_granule_shift</a> will be enlarged appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">ogg_uint32_t</span>: The maximum distance between key frames. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_buf</td><td><span class="tt">ogg_uint32_t</span>: The actual maximum distance set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(ogg_uint32_t)</span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac087983fa951b9148c9db6bc2e81ef4" name="aac087983fa951b9148c9db6bc2e81ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac087983fa951b9148c9db6bc2e81ef4">&#9670;&#160;</a></span>TH_ENCCTL_SET_QUALITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_QUALITY&#160;&#160;&#160;(28)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current encoding quality. </p>
<p>This is only valid so long as no bitrate has been specified, either through the <a class="el" href="structth__info.html" title="Theora bitstream information.">th_info</a> struct used to initialize the encoder or through <a class="el" href="#a9b969df55ecad1acd1ae207fad42592e" title="Sets the current encoding bitrate.">TH_ENCCTL_SET_BITRATE</a> (this restriction may be relaxed in a future version). If it is set before the headers are emitted, the target quality encoded in them will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The new target quality, in the range 0...63, inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>A target bitrate has already been specified, or the quality index was not in the range 0...63. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3befcdd66678f8d27034f9c4b16d1b9c" name="a3befcdd66678f8d27034f9c4b16d1b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3befcdd66678f8d27034f9c4b16d1b9c">&#9670;&#160;</a></span>TH_ENCCTL_SET_QUANT_PARAMS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_QUANT_PARAMS&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the quantization parameters to use. </p>
<p>The parameters are copied, not stored by reference, so they can be freed after this call. <span class="tt">NULL</span> may be specified to revert to the default parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><a class="el" href="structth__quant__info.html" title="A complete set of quantization parameters.">th_quant_info</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>Encoding has already begun, <em class="arg">_buf</em> is <span class="tt">NULL</span> and <em class="arg">_buf_sz</em> is not zero, or <em class="arg">_buf</em> is non-<span class="tt">NULL</span> and <em class="arg">_buf_sz</em> is not <span class="tt">sizeof(<a class="el" href="structth__quant__info.html" title="A complete set of quantization parameters.">th_quant_info</a>)</span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaefb515876b2a180ad5c3120fc584a52" name="aaefb515876b2a180ad5c3120fc584a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefb515876b2a180ad5c3120fc584a52">&#9670;&#160;</a></span>TH_ENCCTL_SET_RATE_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_RATE_BUFFER&#160;&#160;&#160;(22)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the bitrate management bit reservoir as a function of number of frames. </p>
<p>The reservoir size affects how quickly bitrate management reacts to instantaneous changes in the video complexity. Larger reservoirs react more slowly, and provide better overall quality, but require more buffering by a client, adding more latency to live streams. By default, libtheora sets the reservoir to the maximum distance between keyframes, subject to a minimum and maximum limit. This call may be used to increase or decrease the reservoir, increasing or decreasing the allowed temporary variance in bitrate. An implementation may impose some limits on the size of a reservoir it can handle, in which case the actual reservoir size may not be exactly what was requested. The actual value set will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: Requested size of the reservoir measured in frames. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The actual size of the reservoir set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>, or rate control is not enabled. The buffer has an implementation defined minimum and maximum size and the value in _buf will be adjusted to match the actual value set. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a026502e08fbe1af0a1063f39bd18129c" name="a026502e08fbe1af0a1063f39bd18129c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026502e08fbe1af0a1063f39bd18129c">&#9670;&#160;</a></span>TH_ENCCTL_SET_RATE_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_RATE_FLAGS&#160;&#160;&#160;(20)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the default bitrate management behavior. </p>
<p>Use to allow or disallow frame dropping, and to enable or disable capping bit reservoir overflows and underflows. See <a class="el" href="#encctlcodes">the list of available flags</a>. The flags are set by default to <span class="tt"><a class="el" href="#a3e7fab53b902b54135522ba286f45e33" title="Drop frames to keep within bitrate buffer constraints.">TH_RATECTL_DROP_FRAMES</a>|<a class="el" href="#a32f9983b344a431334493cefb0b9337c" title="Ignore bitrate buffer overflows.">TH_RATECTL_CAP_OVERFLOW</a></span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: Any combination of <a class="el" href="#ratectlflags">the available flags</a>:<ul>
<li><a class="el" href="#a3e7fab53b902b54135522ba286f45e33" title="Drop frames to keep within bitrate buffer constraints.">TH_RATECTL_DROP_FRAMES</a>: Enable frame dropping.</li>
<li><a class="el" href="#a32f9983b344a431334493cefb0b9337c" title="Ignore bitrate buffer overflows.">TH_RATECTL_CAP_OVERFLOW</a>: Don't bank excess bits for later use.</li>
<li><a class="el" href="#ad0d62d9dce542caf5296b03b97e020a6" title="Ignore bitrate buffer underflows.">TH_RATECTL_CAP_UNDERFLOW</a>: Don't try to make up shortfalls later. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span> or rate control is not enabled. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd9fbcb6a25a77d991d3620164fe59d6" name="abd9fbcb6a25a77d991d3620164fe59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9fbcb6a25a77d991d3620164fe59d6">&#9670;&#160;</a></span>TH_ENCCTL_SET_SPLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_SPLEVEL&#160;&#160;&#160;(14)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the speed level. </p>
<p>The current speed level may be retrieved using <a class="el" href="#a114b7c552f50b7b8d881a39489af1f61" title="Gets the current speed level.">TH_ENCCTL_GET_SPLEVEL</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: The new encoding speed level. 0 is slowest, larger values use less CPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>, or the encoding speed level is out of bounds. The maximum encoding speed level may be implementation- and encoding mode-specific, and can be obtained via <a class="el" href="#a9baf5bdd206e80c78a8fd44687e89783" title="Gets the maximum speed level.">TH_ENCCTL_GET_SPLEVEL_MAX</a>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation in the current encoding mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a382d685a39a34d8e6ba76b00d804efd8" name="a382d685a39a34d8e6ba76b00d804efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382d685a39a34d8e6ba76b00d804efd8">&#9670;&#160;</a></span>TH_ENCCTL_SET_VP3_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_ENCCTL_SET_VP3_COMPATIBLE&#160;&#160;&#160;(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables any encoder features that would prevent lossless transcoding back to VP3. </p>
<p>This primarily means disabling block-adaptive quantization and always coding all four luma blocks in a macro block when 4MV is used. It also includes using the VP3 quantization tables and Huffman codes; if you set them explicitly after calling this function, the resulting stream will not be VP3-compatible. If you enable VP3-compatibility when encoding 4:2:2 or 4:4:4 source material, or when using a picture region smaller than the full frame (e.g. a non-multiple-of-16 width or height), then non-VP3 bitstream features will still be disabled, but the stream will still not be VP3-compatible, as VP3 was not capable of encoding such formats. If you call this after encoding has already begun, then the quantization tables and codebooks cannot be changed, but the frame-level features will be enabled or disabled as requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: a non-zero value to enable VP3 compatibility, or 0 to disable it (the default). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_buf</td><td><span class="tt">int</span>: 1 if all bitstream features required for VP3-compatibility could be set, and 0 otherwise. The latter will be returned if the pixel format is not 4:2:0, the picture region is smaller than the full frame, or if encoding has begun, preventing the quantization tables and codebooks from being set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_buf</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td><em class="arg">_buf_sz</em> is not <span class="tt">sizeof(int)</span>. </td></tr>
    <tr><td class="paramname">TH_EIMPL</td><td>Not supported by this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32f9983b344a431334493cefb0b9337c" name="a32f9983b344a431334493cefb0b9337c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f9983b344a431334493cefb0b9337c">&#9670;&#160;</a></span>TH_RATECTL_CAP_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_RATECTL_CAP_OVERFLOW&#160;&#160;&#160;(0x2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore bitrate buffer overflows. </p>
<p>If the encoder uses so few bits that the reservoir of available bits overflows, ignore the excess. The encoder will not try to use these extra bits in future frames. At high rates this may cause the result to be undersized, but allows a client to play the stream using a finite buffer; it should normally be enabled, which is the default. </p>

</div>
</div>
<a id="ad0d62d9dce542caf5296b03b97e020a6" name="ad0d62d9dce542caf5296b03b97e020a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d62d9dce542caf5296b03b97e020a6">&#9670;&#160;</a></span>TH_RATECTL_CAP_UNDERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_RATECTL_CAP_UNDERFLOW&#160;&#160;&#160;(0x4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore bitrate buffer underflows. </p>
<p>If the encoder uses so many bits that the reservoir of available bits underflows, ignore the deficit. The encoder will not try to make up these extra bits in future frames. At low rates this may cause the result to be oversized; it should normally be disabled, which is the default. </p>

</div>
</div>
<a id="a3e7fab53b902b54135522ba286f45e33" name="a3e7fab53b902b54135522ba286f45e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7fab53b902b54135522ba286f45e33">&#9670;&#160;</a></span>TH_RATECTL_DROP_FRAMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TH_RATECTL_DROP_FRAMES&#160;&#160;&#160;(0x1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop frames to keep within bitrate buffer constraints. </p>
<p>This can have a severe impact on quality, but is the only way to ensure that bitrate targets are met at low rates during sudden bursts of activity. It is enabled by default. </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="af5cc40472b925456d42526a035d66edd" name="af5cc40472b925456d42526a035d66edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cc40472b925456d42526a035d66edd">&#9670;&#160;</a></span>th_enc_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> <a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The encoder context. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aad036b5967e07629b9be10a4d77ada00" name="aad036b5967e07629b9be10a4d77ada00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad036b5967e07629b9be10a4d77ada00">&#9670;&#160;</a></span>th_encode_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> * th_encode_alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structth__info.html">th_info</a> *</td>          <td class="paramname"><span class="paramname"><em>_info</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an encoder instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_info</td><td>A <a class="el" href="structth__info.html" title="Theora bitstream information.">th_info</a> struct filled with the desired encoding parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The initialized <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>If the encoding parameters were invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a427f6514dfdc01ea72172c469d51d9" name="a3a427f6514dfdc01ea72172c469d51d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a427f6514dfdc01ea72172c469d51d9">&#9670;&#160;</a></span>th_encode_ctl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int th_encode_ctl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>_enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_req</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>_buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>_buf_sz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encoder control function. </p>
<p>This is used to provide advanced control the encoding process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enc</td><td>A <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </td></tr>
    <tr><td class="paramname">_req</td><td>The control code to process. See <a class="el" href="#encctlcodes">the list of available control codes</a> for details. </td></tr>
    <tr><td class="paramname">_buf</td><td>The parameters for this control code. </td></tr>
    <tr><td class="paramname">_buf_sz</td><td>The size of the parameter buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Possible return values depend on the control code used. See <a class="el" href="#encctlcodes">the list of control codes</a> for specific values. Generally 0 indicates success. </dd></dl>

</div>
</div>
<a id="a9439d61b566039d194ff782681fbc408" name="a9439d61b566039d194ff782681fbc408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9439d61b566039d194ff782681fbc408">&#9670;&#160;</a></span>th_encode_flushheader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int th_encode_flushheader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>_enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structth__comment.html">th_comment</a> *</td>          <td class="paramname"><span class="paramname"><em>_comments</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ogg_packet *</td>          <td class="paramname"><span class="paramname"><em>_op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the next header packet. </p>
<p>This should be called repeatedly after encoder initialization until it returns 0 in order to get all of the header packets, in order, before encoding actual video data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enc</td><td>A <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </td></tr>
    <tr><td class="paramname">_comments</td><td>The metadata to place in the comment header, when it is encoded. </td></tr>
    <tr><td class="paramname">_op</td><td>An <span class="tt">ogg_packet</span> structure to fill. All of the elements of this structure will be set, including a pointer to the header data. The memory for the header data is owned by <span class="tt">libtheoraenc</span>, and may be invalidated when the next encoder function is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive value indicates that a header packet was successfully produced. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No packet was produced, and no more header packets remain. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em>, <em class="arg">_comments</em>, or <em class="arg">_op</em> was <span class="tt">NULL</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b23d216532231925c4107894204680" name="a36b23d216532231925c4107894204680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b23d216532231925c4107894204680">&#9670;&#160;</a></span>th_encode_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void th_encode_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>_enc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees an allocated encoder instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enc</td><td>A <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d8ac1dda53187455352f99bbb5b04b" name="a96d8ac1dda53187455352f99bbb5b04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d8ac1dda53187455352f99bbb5b04b">&#9670;&#160;</a></span>th_encode_packetout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int th_encode_packetout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>_enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ogg_packet *</td>          <td class="paramname"><span class="paramname"><em>_op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves encoded video data packets. </p>
<p>This should be called repeatedly after each frame is submitted to flush any encoded packets, until it returns 0. The encoder will not buffer these packets as subsequent frames are compressed, so a failure to do so will result in lost video data. </p><dl class="section note"><dt>Note</dt><dd>Currently the encoder operates in a one-frame-in, one-packet-out manner. However, this may be changed in the future. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enc</td><td>A <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </td></tr>
    <tr><td class="paramname">_last</td><td>Set this flag to a non-zero value if no more uncompressed frames will be submitted. This ensures that a proper EOS flag is set on the last packet. </td></tr>
    <tr><td class="paramname">_op</td><td>An <span class="tt">ogg_packet</span> structure to fill. All of the elements of this structure will be set, including a pointer to the video data. The memory for the video data is owned by <span class="tt">libtheoraenc</span>, and may be invalidated when the next encoder function is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive value indicates that a video data packet was successfully produced. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>No packet was produced, and no more encoded video data remains. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_op</em> was <span class="tt">NULL</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe7dd66b411c2d61ab8153c15308750" name="adbe7dd66b411c2d61ab8153c15308750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe7dd66b411c2d61ab8153c15308750">&#9670;&#160;</a></span>th_encode_ycbcr_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int th_encode_ycbcr_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af5cc40472b925456d42526a035d66edd">th_enc_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>_enc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="codec_8h.html#a343f7cfabad179cc4fe527cf06873f45">th_ycbcr_buffer</a></td>          <td class="paramname"><span class="paramname"><em>_ycbcr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submits an uncompressed frame to the encoder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_enc</td><td>A <a class="el" href="#af5cc40472b925456d42526a035d66edd" title="The encoder context.">th_enc_ctx</a> handle. </td></tr>
    <tr><td class="paramname">_ycbcr</td><td>A buffer of Y'CbCr data to encode. If the width and height of the buffer matches the frame size the encoder was initialized with, the encoder will only reference the portion inside the picture region. Any data outside this region will be ignored, and need not map to a valid address. Alternatively, you can pass a buffer equal to the size of the picture region, if this is less than the full frame size. When using subsampled chroma planes, odd picture sizes or odd picture offsets may require an unexpected chroma plane size, and their use is generally discouraged, as they will not be well-supported by players and other media frameworks. See Section 4.4 of <a href="https://www.theora.org/doc/Theora.pdf">the Theora specification</a> for details if you wish to use them anyway. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">TH_EFAULT</td><td><em class="arg">_enc</em> or <em class="arg">_ycbcr</em> is <span class="tt">NULL</span>. </td></tr>
    <tr><td class="paramname">TH_EINVAL</td><td>The buffer size matches neither the frame size nor the picture size the encoder was initialized with, or encoding has already completed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e" name="aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1f7cb1fa0d3b7cc1d4ca0f17e6ae5e">&#9670;&#160;</a></span>TH_VP31_HUFF_CODES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structth__huff__code.html">th_huff_code</a> TH_VP31_HUFF_CODES[<a class="el" href="codec_8h.html#a49bf449eae33c5320f0c308f32c6ae42">TH_NHUFFMAN_TABLES</a>][<a class="el" href="codec_8h.html#a2a44f48084e76a58cae48fb5d47cd422">TH_NDCT_TOKENS</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Huffman tables used by VP3. </p>

</div>
</div>
<a id="a3b1b462989f4e7a5a98e6e697f1a7f7d" name="a3b1b462989f4e7a5a98e6e697f1a7f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b462989f4e7a5a98e6e697f1a7f7d">&#9670;&#160;</a></span>TH_VP31_QUANT_INFO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structth__quant__info.html">th_quant_info</a> TH_VP31_QUANT_INFO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The quantization parameters used by VP3. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for libtheora by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
